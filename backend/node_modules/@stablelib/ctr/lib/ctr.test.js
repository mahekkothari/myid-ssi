"use strict";
// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", { value: true });
const aes_1 = require("@stablelib/aes");
const hex_1 = require("@stablelib/hex");
const ctr_1 = require("./ctr");
describe("AES-CTR", () => {
    const v = {
        key: "000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F",
        iv: "202122232425262728292A2B2C2D2E2F",
        src1: "000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122",
        dst1: "61A7916D4A8A161B14C8F398B94FAEDBA3A3E29AD93F55451ED31FE92D3ABF841C7C81",
        src2: "00000000000000000000",
        dst2: "CA4E6112D03D4890166B"
    };
    it("should correctly encrypt", () => {
        const cipher = new aes_1.AES((0, hex_1.decode)(v.key));
        const ctr = new ctr_1.CTR(cipher, (0, hex_1.decode)(v.iv));
        const dst1 = new Uint8Array((0, hex_1.decode)(v.dst1).length);
        ctr.streamXOR((0, hex_1.decode)(v.src1), dst1);
        expect((0, hex_1.encode)(dst1)).toBe(v.dst1);
        // Continue the same stream.
        const dst2 = new Uint8Array((0, hex_1.decode)(v.dst2).length);
        ctr.streamXOR((0, hex_1.decode)(v.src2), dst2);
        expect((0, hex_1.encode)(dst2)).toBe(v.dst2);
    });
    it("should produce correct stream", () => {
        const cipher = new aes_1.AES((0, hex_1.decode)(v.key));
        const ctr = new ctr_1.CTR(cipher, (0, hex_1.decode)(v.iv));
        const dst1 = new Uint8Array((0, hex_1.decode)(v.dst1).length);
        const src1 = (0, hex_1.decode)(v.src1);
        ctr.stream(dst1);
        for (let i = 0; i < dst1.length; i++) {
            dst1[i] ^= src1[i];
        }
        expect((0, hex_1.encode)(dst1)).toBe(v.dst1);
        // Continue the same stream.
        const dst2 = new Uint8Array((0, hex_1.decode)(v.dst2).length);
        const src2 = (0, hex_1.decode)(v.src2);
        ctr.stream(dst2);
        for (let i = 0; i < dst2.length; i++) {
            dst2[i] ^= src2[i];
        }
        expect((0, hex_1.encode)(dst2)).toBe(v.dst2);
    });
    it("should generate succession when calling multiple times", () => {
        const cipher = new aes_1.AES((0, hex_1.decode)(v.key));
        const dst1 = new Uint8Array(100);
        const dst2 = new Uint8Array(dst1.length);
        // full-length
        const ctr1 = new ctr_1.CTR(cipher, (0, hex_1.decode)(v.iv));
        ctr1.stream(dst1);
        // partial
        const ctr2 = new ctr_1.CTR(cipher, (0, hex_1.decode)(v.iv));
        ctr2.stream(dst2.subarray(0, 50));
        ctr2.stream(dst2.subarray(50));
        expect((0, hex_1.encode)(dst2)).toEqual((0, hex_1.encode)(dst1));
    });
});
//# sourceMappingURL=ctr.test.js.map